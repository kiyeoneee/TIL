# 4장. 클래스와 인터페이스

## 목차

- [Item 15. 클래스와 멤버의 접근 권한을 최소화하라](#Item-15-클래스와-멤버의-접근-권한을-최소화하라)
- [Item 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라](#Item-16-public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라)
- [Item 17. 변경 가능성을 최소화하라](#Item-17-변경-가능성을-최소화하라)
- [Item 18. 상속보다는 컴포지션을 사용하라](#Item-18-상속보다는-컴포지션을-사용하라)
- [Additional Keyword](#Additional-Keyword)

---

## Item 15. 클래스와 멤버의 접근 권한을 최소화하라

* 잘 설계된 컴포넌트? 클래스 내부 데이터 & 구현 정보를 외부 컴포넌트로부터 잘 숨김
* 정보 은닉의 장점  
  * 여러 컴포넌트의 병렬 개발이 가능하게 하여 개발 속도를 높임
  * 컴포넌트의 분리로 컴포넌트 교체 부담을 줄여 시스템 관리 비용을 낮춤
  * 성능 최적화에 도움
  * 재사용성 향상
  * 컴포넌트의 개별 검증이 가능하므로 큰 시스템을 제작하는 난이도를 낮춰줌
* 접근 제어 메커니즘을 활용하여 정보 은닉을 이루자
  * 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 함
    * Top level Class & Interface 
      * package-private 또는 public, 패키지 외부에서 쓸 이유가 없다면 꼭 package-private
      * 한 클래스에서만 사용한다면 해당 클래스 안에 private static으로 중첩
    * 일반 클래스
      * 정말 public으로 선언해야 할지 확인
      * 꼭 public이어야 하는 이유가 없다면 package-private으로 구현
    * 멤버 (필드, 메서드, 중첩 클래스, 중첩 인터페이스)
      * private
      * package-private (일반 클래스의 default)
      * protected : package-private 포함 및 해당 클래스의 하위 클래스에서 제약적 접근 가능
      * public
  * 멤버 접근성을 좁히지 못하게 하는 제약
    * 상위 클래스의 메서드를 재정의할 때, 상위 클래스에서보다 좁게 설정 불가 (리스코프 치환 원칙)
  * 테스트만을 위해 private/package-private 이상의 접근 제어 설정은 안됨
  * 불변 보장을 위해 public 클래스의 인스턴스 필드는 되도록 public을 지양
    * public 가변 필드를 가지는 클래스는 보통 스레드 안전하지 않음

<br>

## Item 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

* Bad  

  ```java
  class Point {
    public double x;
    public double y;
  }
  ```

* Good  

  ```java
  class Point {
    public double x;
    public double y;
    
    public Point(double x, double y) {
      this.x = x;
      this.y = y;
    }
    
    public double getX() { return x; }
    public double getY() { return y; }
    
    public void setX(double x) { this.x = x; }
    public void setY(double y) { this.y = y; }
  }
  ```

<br>

## Item 17. 변경 가능성을 최소화하라

* 클래스를 불변으로 만들기 위한 규칙
  * 변경자를 제공하지 않음
  * 클래스를 확장할 수 없도록 함
  * 모든 필드를 final로 선언
  * 모든 필드는 private
  * 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 함
    * 접근자 메서드 주의, 방어적 복사를 수행할 것
* 불변 객체의 메서드는 자신의 값을 수정하여 반환하지 않고, 새로운 인스턴스를 만들어 반환해야 함
* **장점**
  * 불변 객체는 스레드 안전하여 동기화 할 필요가 없음
  * 다른 스레드에 영향을 주지 않으므로 공유가 용이
    * 재활용 권장
    * 자주 사용하는 인스턴스는 캐싱하여 정적 팩터리 메서드로 제공
    * 복사는 지양
  * 불변 객체끼리는 내부 데이터를 공유 가능
  * 객체 설계 시 다른 불변 객체들을 구성요소로 사용하면 해당 객체도 불변식을 유지하기 용이
  * 실패 원자성을 제공
* **단점**
  * 값이 다르면 반드시 독립된 객체로 만들어야 하므로 많은 비용이 들 수 있음
    * 다단계 연산들을 예측하여 기본 기능으로 제공하여 각 단계마다 객체를 생성하지 않도록 함
    * 클라이언트들이 요구하는 연산들의 예측이 가능하다면 가변 동반 클래스를 구현 (eg. String의 가변 클래스 StringBuilder)
* 불변 클래스를 상속하지 못하게 하는 방법
  * final 클래스 선언
  * 모든 생성자는 private/package-private으로 정의하고 정적 팩터리 메서드를 제공
* 생성자는 불변식 설정이 모두 완료된 초기화가 끝난 상태의 객체만을 생성해야 함

<br>

## Item 18. 상속보다는 컴포지션을 사용하라



<br>

---

## Additional Keyword

### Item 15

* Collections.unmodifiableList();
* Java 9
  * 모듈 시스템
    패키지들의 모음인 모듈은 자신에 속하는 패키지 중 공개 할 것들을 module-info.java에 선언하여 관리

### Item 17

* 함수형 프로그래밍
  * 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴
* 실패 원자성
  * 메서드에서 예외가 발생한 후에도 그 객체는 여전히 호출 이전과 같은 상태여야 함
* java.util.concurrent.CountDownLatch

