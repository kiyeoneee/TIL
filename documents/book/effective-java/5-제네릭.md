# 5장. 제네릭

## 목차

- [Item 25. 로 타입은 사용하지 말라](#Item-25-로-타입은-사용하지-말라)
- [Additional Keyword](#Additional-Keyword)

---

> Java 5 부터 지원
> 제네릭을 사용하면 컴파일러가 타입을 확인할 수 있어 알아서 형변환 코드를 추가 해 주고, 컴파일 과정에서 엉뚱한 타입의 객체를 넘기는 것을 막을 수 있음
> 제네릭 타입 = 제네릭 클래스 + 제네릭 인터페이스

## Item 25. 로 타입은 사용하지 말라

* 로 타입이란?
  제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때 (eg. List<E>의 로타입은 List)

* 로 타입을 사용하면 타입이 달라 발생할 수 있는 문제를 컴파일 타임에 잡아낼 수 없음

  ```java
  // Stamp 인스턴스만 취급하는 컬렉션
  private final Collection stamps = ...;
  
  stamps.add(new Coin(...));
  
  for (Iterator i = stamps.iterator(); i.hasNext();) {
    Stamp stamp = (Stamp) i.next();  // 런타임에 ClassCastException이 발생하지만 컴파일 타임에 발견 불가
    ...
  } 
  
  // 개선안
  private final Collection<Stamp> stamps = ...;
  ```

* List vs List<Object>
  로타입 List는 매개변수로 사용될 때 하위타입인 List<String>를 넘길 수 있지만 List<Object>는 불가능
  제네릭 하위 타입 규칙에 의한 현상인데, 이러한 문제 때문에 로타입은 타입 안정성을 잃을 수 있음

* 원소의 타입을 몰라도 될 때는 로타입을 쓰기보다 어떤 타입이라도 담을 수 있는 비한정적 와일드 카드를 쓸 것

  ```java
  static int numElementsInCommon(Set s1, Set s2) {  // 로타입으로 정의 시 s1, s2의 타입이 다르면 문제 발생
    int result = 0;
    for (Object o1 : s1)
      if (s2.contains(o1))
        result++;
    return result;
  }
  
  // 위 방법 대신 이렇게 정의하자!
  static int numElementsInCommon(Set<?> s1, Set<?> s2) { ... }
  ```

* instanced 연산은 로 타입이나 비한정적 와일드카드 타입이나 똑같이 동작하므로 로타입을 사용하는 것이 더 좋음

<br>

---

## Additional Keyword

### 

