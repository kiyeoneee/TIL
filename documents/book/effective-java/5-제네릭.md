# 5장. 제네릭

## 목차

- [Item 26. 로 타입은 사용하지 말라](#Item-25-로-타입은-사용하지-말라)
- [Item 27. 비검사 경고를 제거하라](#Item 27. 비검사 경고를 제거하라)
- [Item 28. 배열보다는 리스트를 사용하라](#Item-28-배열보다는-리스트를-사용하라)
- [Item 29. 이왕이면 제네릭 타입으로 만들라](#Item-29-이왕이면-제네릭-타입으로-만들라)
- [Additional Keyword](#Additional-Keyword)

---

> Java 5 부터 지원
> 제네릭을 사용하면 컴파일러가 타입을 확인할 수 있어 알아서 형변환 코드를 추가 해 주고, 컴파일 과정에서 엉뚱한 타입의 객체를 넘기는 것을 막을 수 있음
> 제네릭 타입 = 제네릭 클래스 + 제네릭 인터페이스

## Item 26. 로 타입은 사용하지 말라

* 로 타입이란?
  제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때 (eg. List<E>의 로타입은 List)

* 로 타입을 사용하면 타입이 달라 발생할 수 있는 문제를 컴파일 타임에 잡아낼 수 없음

  ```java
  // Stamp 인스턴스만 취급하는 컬렉션
  private final Collection stamps = ...;
  
  stamps.add(new Coin(...));
  
  for (Iterator i = stamps.iterator(); i.hasNext();) {
    Stamp stamp = (Stamp) i.next();  // 런타임에 ClassCastException이 발생하지만 컴파일 타임에 발견 불가
    ...
  } 
  
  // 개선안
  private final Collection<Stamp> stamps = ...;
  ```

* List vs List<Object>
  로타입 List는 매개변수로 사용될 때 하위타입인 List<String>를 넘길 수 있지만 List<Object>는 불가능
  제네릭 하위 타입 규칙에 의한 현상인데, 이러한 문제 때문에 로타입은 타입 안정성을 잃을 수 있음

* 원소의 타입을 몰라도 될 때는 로타입을 쓰기보다 어떤 타입이라도 담을 수 있는 비한정적 와일드 카드를 쓸 것

  ```java
  static int numElementsInCommon(Set s1, Set s2) {  // 로타입으로 정의 시 s1, s2의 타입이 다르면 문제 발생
    int result = 0;
    for (Object o1 : s1)
      if (s2.contains(o1))
        result++;
    return result;
  }
  
  // 위 방법 대신 이렇게 정의하자!
  static int numElementsInCommon(Set<?> s1, Set<?> s2) { ... }
  ```

* instanced 연산은 로 타입이나 비한정적 와일드카드 타입이나 똑같이 동작하므로 로타입을 사용하는 것이 더 좋음

<br>

## Item 27. 비검사 경고를 제거하라

비검사 경고란? `warning: [unchecked]` 포맷으로 출력되며 casting할 때 자료형을 검사하지 않아서 뜨는 경고
대부분 쉽게 해결 가능하니 비검사 경고를 모두 해결하도록 하여 코드의 타입 안정성을 보장할 것 

해결 방법?

- Java7의 다이아몬드 연산자(<>)를 사용

  ```java
  // 경고 발생
  Set<Lark> exaltation = new HashSet();
  
  // 다이아몬드 연산자 반영
  Set<Lark> exaltation = new HashSet<>();
  ```

- @SuppressWarnings("unchecked") 어노테이션으로 해결

  - 타입 안정성이 분명한 경우에는 용이하지만 런타임시에 Exception이 발생할 수 있음
  - 진짜 문제를 알리는 새로운 경고를 놓칠 수 있으므로 클래스와 개별 지역변수까지 모두 달 수 있지만 가능한 한 가장 좁은 범위에 적용할 것
  - 경고를 무시해도 되는 이유를 주석으로 꼭 남겨주기

<br>

## Item 28. 배열보다는 리스트를 사용하라

배열 : 공변 (함께 변한다)

```java
// 런타임에 실패
Object[] objectAry = new Long[1];  // 초기화에 사용된 객체가 하위 객체이면 자동으로 casting 됨
objectArray[0] = "타입이 달라 넣을 수 없다.";  // throw ArrayStoreException
```

리스트 : 불공변

```java
// 컴파일 불가
List<Object> ol = new ArrayList<Long>();  // 여기에서 부터 호환되지 않는 타입이기에 컴파일 실패
ol.add("타입이 달라 넣을 수 없다.");
```

<br>

## Item 29. 이왕이면 제네릭 타입으로 만들라

**Before**

```java
public class Stack {
  private Object[] elements;  // 제네릭 타입으로 변환할 때 실체화 불가 티입으로 배열을 만들지 못하는 부분을 고려할 것
  private int size = 0;
  private static final int DEFAULT_INITIAL_CAPACITY = 16;
  
  public Stack() {
    elements = new Object[DEFAULT_INITIAL_CAPACITY];
  }
  
  public void push(Object e) {
    ensureCapacity();
    elements[size++] = e;
  }
  
  public Object pop() {
    if (size == 0)
      throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null;
    return result;
  }
  
  public boolean isEmpty() {
    return size == 0;
  }
  
  private void ensureCapacity() {
    if (elements.length == size) 
      elements = Arrays.copyOf(elements, 2 * size + 1);
  }
}
```

**After : 제네릭 타입으로 변환 시 실체화 불가 타입으로 인해 배열을 만들지 못하는 문제를 두 가지 방법으로 해결할 수 있음**

1. 클래스 선언에 타입 매개 변수를 추가 (보통 현업에서 사용되는 방법)

   ```java
   public class Stack<E> {
     private E[] elements;  
     private int size = 0;
     private static final int DEFAULT_INITIAL_CAPACITY = 16;
     
     @SuppressWarnings("unchecked")  // 반드시 런타임에 타입 안정성을 헤치지 않음을 확인해야 함
     public Stack() {
       elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
     }
     
     public void push(E e) {
       ensureCapacity();
       elements[size++] = e;
     }
     
     public E pop() {
       if (size == 0)
         throw new EmptyStackException();
       E result = elements[--size];
       elements[size] = null;
       return result;
     }
     
     ...
   }
   ```

2. elements 배열의 타입을 Object로 하고 반환 결과 값을 형 변환 해줌

   ```java
   public class Stack<E> {
     private Object[] elements;  
     private int size = 0;
     private static final int DEFAULT_INITIAL_CAPACITY = 16;
     
     ...
       
     public E pop() {
       if (size == 0)
         throw new EmptyStackException();
       
       // 런타임 시 컴파일 시와 타입이 달라 힙 오염이 일어날 수 있음
       @SuppressWarnings("unchecked") E result = (E) elements[--size];
       
       elements[size] = null;
       return result;
     }
     
     ...
   }
   ```






<br>

---

## Additional Keyword

### 

