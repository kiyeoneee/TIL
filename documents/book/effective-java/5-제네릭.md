# 5장. 제네릭

## 목차

- [Item 26. 로 타입은 사용하지 말라](#Item-25-로-타입은-사용하지-말라)
- [Item 27. 비검사 경고를 제거하라](#Item 27. 비검사 경고를 제거하라)
- [Additional Keyword](#Additional-Keyword)

---

> Java 5 부터 지원
> 제네릭을 사용하면 컴파일러가 타입을 확인할 수 있어 알아서 형변환 코드를 추가 해 주고, 컴파일 과정에서 엉뚱한 타입의 객체를 넘기는 것을 막을 수 있음
> 제네릭 타입 = 제네릭 클래스 + 제네릭 인터페이스

## Item 26. 로 타입은 사용하지 말라

* 로 타입이란?
  제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때 (eg. List<E>의 로타입은 List)

* 로 타입을 사용하면 타입이 달라 발생할 수 있는 문제를 컴파일 타임에 잡아낼 수 없음

  ```java
  // Stamp 인스턴스만 취급하는 컬렉션
  private final Collection stamps = ...;
  
  stamps.add(new Coin(...));
  
  for (Iterator i = stamps.iterator(); i.hasNext();) {
    Stamp stamp = (Stamp) i.next();  // 런타임에 ClassCastException이 발생하지만 컴파일 타임에 발견 불가
    ...
  } 
  
  // 개선안
  private final Collection<Stamp> stamps = ...;
  ```

* List vs List<Object>
  로타입 List는 매개변수로 사용될 때 하위타입인 List<String>를 넘길 수 있지만 List<Object>는 불가능
  제네릭 하위 타입 규칙에 의한 현상인데, 이러한 문제 때문에 로타입은 타입 안정성을 잃을 수 있음

* 원소의 타입을 몰라도 될 때는 로타입을 쓰기보다 어떤 타입이라도 담을 수 있는 비한정적 와일드 카드를 쓸 것

  ```java
  static int numElementsInCommon(Set s1, Set s2) {  // 로타입으로 정의 시 s1, s2의 타입이 다르면 문제 발생
    int result = 0;
    for (Object o1 : s1)
      if (s2.contains(o1))
        result++;
    return result;
  }
  
  // 위 방법 대신 이렇게 정의하자!
  static int numElementsInCommon(Set<?> s1, Set<?> s2) { ... }
  ```

* instanced 연산은 로 타입이나 비한정적 와일드카드 타입이나 똑같이 동작하므로 로타입을 사용하는 것이 더 좋음

<br>

## Item 27. 비검사 경고를 제거하라

비검사 경고란? `warning: [unchecked]` 포맷으로 출력되며 casting할 때 자료형을 검사하지 않아서 뜨는 경고
대부분 쉽게 해결 가능하니 비검사 경고를 모두 해결하도록 하여 코드의 타입 안정성을 보장할 것 

해결 방법?

- Java7의 다이아몬드 연산자(<>)를 사용

  ```java
  // 경고 발생
  Set<Lark> exaltation = new HashSet();
  
  // 다이아몬드 연산자 반영
  Set<Lark> exaltation = new HashSet<>();
  ```

- @SuppressWarnings("unchecked") 어노테이션으로 해결

  - 타입 안정성이 분명한 경우에는 용이하지만 런타임시에 Exception이 발생할 수 있음
  - 진짜 문제를 알리는 새로운 경고를 놓칠 수 있으므로 클래스와 개별 지역변수까지 모두 달 수 있지만 가능한 한 가장 좁은 범위에 적용할 것
  - 경고를 무시해도 되는 이유를 주석으로 꼭 남겨주기

<br>

## Item 28. 배열보다는 리스트를 사용하라

배열 : 공변 (함께 변한다)

```java
// 런타임에 실패
Object[] objectAry = new Long[1];  // 초기화에 사용된 객체가 하위 객체이면 자동으로 casting 됨
objectArray[0] = "타입이 달라 넣을 수 없다.";  // throw ArrayStoreException
```

리스트 : 불공변

```java
// 컴파일 불가
List<Object> ol = new ArrayList<Long>();  // 여기에서 부터 호환되지 않는 타입이기에 컴파일 실패
ol.add("타입이 달라 넣을 수 없다.");
```



<br>

---

## Additional Keyword

### 

