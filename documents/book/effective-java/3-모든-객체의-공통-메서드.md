# 3장. 모든 객체의 공통 메서드

## 목차

- [Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라](#Item-1-생성자-대신-정적-팩터리-메서드를-고려하라)
- [Additional Keyword](#Additional-Keyword)

---

> Object final이 아닌 메서드(equals, hashCode, toString, clone, finalize)는 일반 규약에 맞게 재정의 됨을 염두에 두고 설계되었음   
> Object를 상속하는 클래스, 즉 모든 클래스는 위 메서드를 재정의 해야 함

<br>

## Item 10. equals는 일반 규약을 지켜 재정의하라

**요약!** equals는 꼭 필요한 경우가 아니면 재정의를 피하여 의도치 않은 문제를 일으키지 않도록 하자

* equals 메서드는 아래의 상황일 경우 재정의 하지 않음
  * 각 인스턴스가 본질적으로 고유 : 단순히 값이 아닌 고유한 동작 개체일 경우 (eg. Thread, Enum)
  * 논리적 동치성을 검사할 일이 없는 경우
  * 상위 클래스에서 재정의한 equals를 따를 경우
  * 클래스가 private/package-private이고 equals 메서드를 호출할 일이 없는 경우
* equals를 재정의해야 할 때
  * 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 이를 포함하지 않는 경우
* 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않음
* equals 재정의 일반 규약
  * 반사성
  * 대칭성
  * 추이성
    * 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않으므로 유의해야 함
  * 일관성
    * 자원이 일관성을 띄지 않으면 equals는 일관성을 유지하기 어려움
    * 메모리에 존재하는 객체만을 사용한 결정적 계산만 수행
  * null-아님
    * 건네받은 객체를 가장 먼저 instanceof 연산자로 검사 (명시적 null check를 피하자)
* equals 메서드 구현 단계
  1. == 연산자로 자기 자신의 참조인지 확인
  2. instanceof 연산자로 타입 확인
  3. 입력을 올바른 타입으로 형변환
  4. 모든 핵심 필드들의 일치 여부 확인
* equals를 재정의할 땐 hashCode도 반드시 재정의

<br>

---

## Additional Keyword

### 