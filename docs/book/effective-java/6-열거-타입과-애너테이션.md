# 6장. 열거 타입과 애너테이션

## 목차

- [Item 34. int 상수 대신 열거 타입을 사용하라](#Item-34-int-상수-대신-열거-타입을-사용하라)
- [Item 35. ordinal 메서드 대신 인스턴스 필드를 사용하라](#Item-35-ordinal-메서드-대신-인스턴스-필드를-사용하라)
- [Additional Keyword](#Additional-Keyword)

---

## Item 34. int 상수 대신 열거 타입을 사용하라

**Bad : 정수 열거 패턴**

```java
public static final int APPLE_FUJI					= 0;
public static final int APPLE_PIPPIN				= 1;
public static final int APPLE_GRANNY_SMITH	= 2;

public static final int ORANGE_NAVEL				= 0;
public static final int ORANGE_TEMPLE				= 1;
public static final int ORANGE_BLOOD				= 2;
```

* 별도의 namespace가 없어 접두어로 상수 이름을 구현해 표현력이 좋지 않음
* 컴파일러가 동등 연산자(==) 비교를 찾아낼 수 없음
* 컴파일 시 값이 고정되기 때문에 값이 바뀌게 되면 클라이언트도 다시 컴파일해야 한다

**Good : 열거 타입**

필요한 원소를 컴파일타임에 다 알 수 잇는 상수 집합이라면 항상 열거 타입을 사용할 것!!

```java
public enum Planet {
  MERCURY(3.302e+32, 2.439e6),
  VENUS(4.869e+24, 6.052e6),
  EARTH(5.975e+24, 6.378e6);
  
  // 열거 타입은 기본적으로 불변이어서, 모든 타입은 final이어야 함
  private final double mass;
  private final double radius;
  private final double surfaceGravity;
  
  private static final double G = 6.67300E-11;
  
  Planet(double mass, double radius) {
    this.mass = mass;
    this.radius = radius;
    surfaceGravity = G * mass / (radius * radius);
  }
  
  public double mass() {
    return mass;
  }
  
  public double radius() {
    return radius;
  }
  
  public double surfaceGravity() {
    return surfaceGravity;
  }
  
  public double surfaceWeight(double mass) {
    return mass * surfaceGravity;
  }
}

// 클라이언트
public class WeightTable {
  public static void main(String[] args) {
    double earthWeight = Double.parseDouble(args[0]);
    double mass = earthWeight / Planet.EARTH.surfaceGravity();
    for (Planet p : Planet.values())
      System.out.println("%s에서의 무게는 %f이다.%n", p, p.surfaceWeight(mass));
  }
}
```

* 임의의 메서트나 필드 추가, 인터페이스 구현 가능

* Comparable, Serializable이 구현되어 있음

* 추상 메서드를 정의하여 상수별로 다르게 동작하는 코드를 구현할 수 있음

* 열거 타입에 상수별 동작을 혼합해야 할 때는 switch 문 보다는 **전략 열거 타입 패턴**을 사용할 것

  ```java
  enum PayrollDay {
    MONDAY(WEEKDAY), TUESDAY(WEEKDAY), WEDNESDAY(WEEKDAY), TURSDAY(WEEKDAY), FRIDAY(WEEKDAY),
    SATURDAY(WEEKEND), SUNDAY(WEEKDAY);
    
    private final PayType payType;
    
    PayrollDay(PayType payType) { this.payType = payTypel }
    
    // Bad
    int pay(int minutesWorked, int payRate) {
      int basePay = minutesWorked * payRate;
      
      int overtimePay;
      switch(this) {
        case SATURDAY: case SUNDAY;
          overtimePay = basePay / 2;
          break;
        default:
          overtimePay = minutesWorked <= MINS_PER_SHIFT ? 0 : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;
      }
      
      return basePay + overtimePay;
    }
    
    // Good
    int pay(int minutesWorked, int payRate) {
      return payType.pay(minutesWorked, payRate);
    }
    
    enum PayType {
      WEEKDAY {
        int overtimePay(int minsWorked, int payRate) {
          return minsWorked <= MINS_PER_SHIFT ? 0 : (minsWorked - MINS_PER_SHIFT) * payRate / 2;
        }
      },
      WEEKEND {
        int overtimePay(int minsWorked, int payRate) {
          return minsWorked * payRate / 2;
        }
      };
      
      abstract int overtimePay(int minsWorked, int payRate);
      private static final int MINS_PER_SHIFT = 8 * 60;
      
      int pay(int minsWorked, int payRate) {
        int basePay = minsWorked * payRate;
        return basePay + overtimePay(minsWorked, payRate);
      }
    }
  }
  ```

  * 상수별 동작을 혼합해 넣을 때는 switch 문이 더 좋은 선택일 수 있음

<br>

## Item 35. ordinal 메서드 대신 인스턴스 필드를 사용하라

### ordinal 메서드란?

* 열거 타입의 상수가 해당 타입에서 몇 번째 위치인지를 반환하는 메서드
* 중간 값을 비워둘 수 없고, 중복되는 위치 정보가 필요한 경우 대응 불가 (8명이 연주하는 8중주, 복4주를 구분할 수 없음)
* 열거 타입 상수에 연결된 값은 ordinal 메서드로 얻지 말고 인스턴스 필드에 자장하자! (중복 가능, 중간 값 누락 가능)

**Bad : ordinal 메서드 사용**

```java
public enum Ensemble {
  SOLO, DUET, TRIO, QUARTET, QUINTET,
  SEXTET, SEPTET, OCTET, NONET, DECTET;
  
  public int numberOfMusicians() {
    return ordinal() + 1;
  }
}
```

**Good : 인스턴스 필드 사용**

```java
public enum Ensemble {
  SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),
  SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),
  NONET(9), DECTET(10), TRIPLE_QUARTET(12);

  private final int numberOfMusicians;
  Ensemble(int size) { this.numberOfMusicians = size; }
  public int numberOfMusicians() { return numberOfMusicians; }
}
```

<br>

## Item 36. 비트 필드 대신 EnumSet을 사용하라

<br>

---

## Additional Keyword

###Item 34