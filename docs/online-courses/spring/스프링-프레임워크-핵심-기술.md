# 스프링 프레임워크 핵심기술

> **url** : https://www.inflearn.com/course/spring-framework_core/dashboard
> **강사** : 백기선
>
> 스프링을 잘 모르면서 사용하다보니 이대로는 안되겠다 하는 시점들이 자주 찾아온다ㅠㅠ
> 더는 미룰 수 없어서 수강하는 스프링 프레임워크 핵심기술!



# 0. 소개

#### 스프링이란?

* 소규모 애플리케이션 또는 기업용 애플리케이션을 자바로 개발하는데 있어 유용하고 편리한 기능을 제공하는 프레임워크

### 디자인 철학

* 모든 선택은 개발자의 몫
* 다양한 관점을 지향하여 유연성을 높임
* 하위 호환성을 지킴
* API를 신중하게 설계
* 높은 수준의 코드 지향

<br>

# 1. IoC 컨테이너와 빈

## 1부. 스프링 IoC 컨테이너와 빈

### IoC란?

> 의존 관계 주입 ( Inversion of Control )
> 한 클래스에서 사용할 의존 객체를 생성자를 사용해 직접 만들어서 사용하는 것이 아니라, 주입받아서 사용하는 방법



### IoC 컨테이너

* BeanFactory interface가 가장 핵심
* 어플리케이션 컴포넌트의 중앙 저장소
* 빈 설정 소스로 부터 빈 정의를 읽어들이고, 빈을 구성하고 제공



### Bean

* 스프링 IoC 컨테이너가 관리하는 객체

* 장점

  * 의존성 관리
  * 스코프
    * 싱글톤 : 하나만 만들어서
    * 프로토타입 : 매번 다른 객체
  * 라이프사이클 인터페이스

  

#### ApplicationContext

실질적으로 우리가 가장 많이 사용하게 될 BeanFactory
BeanFactory를 상속하여 기본적인 BeanFactory의 기능을 수행하면서 추가적인 기능들을 제공

* BeanFactory
* 메세지 소스 처리 기능 (i18n)
* 이벤트 발행 기능
* 리소스 로딩 기능
* ...

<br>

## 2부. ApplicationContext와 다양한 빈 설정 방법

### Bean을 정의하는 방법은 어노테이션 외에도 xml 파일로 가능

application.xml

```xml
<bean id="소문자 시작, camelCase" class="해당 클라스 package.ClassName">
  <property name="상속 받을 클래스 내부에 인스턴스 변수 명" ref="다른 bean id" />
</bean>
```

application.java

```java
public class Application {
  public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
    String[] beanDefinitionNames = context.getBeanDefinitionNames();
    System.out.println(Arrays.toString(beanDefinitionNames));
    BookService bookService = (BookService) context.getBean("bookService");
  }
}
```

이러한 방법은 매우 불편하다!

```xml
<context:component-scan base-package="스프링 컨테이너가 관리할 package"/>
```

근데 java로 컨피그 파일을 만들 수는 없을까?

```java
@Configuration
//@ComponentScan(basePackageClasses = Application.class)  
// 이 클래스가 위치한 곳부터 component 스캐닝을 해라
// ComponentScan 어노테이션을 달면 아래의 bean 정의는 모두 삭제해도 됨
public class ApplicationConfig {
    @Bean
    public BookRepository bookRepository() {
        return new BookRepository();
    }

    @Bean
    public BookService bookService(BookRepository bookRepository) {
        return new BookService(bookRepository);
    }
}

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class);
        String[] beanDefinitionNames = context.getBeanDefinitionNames();
        System.out.println(Arrays.toString(beanDefinitionNames));
        BookService bookService = (BookService) context.getBean("bookService");

        System.out.println(bookService.bookRepository != null);
    }
}

```

SpringBoot를 사용한다면 이러한 bean 정의를 모두 생략할 수 있다.

```java
// ComponentScan 어노테이션을 포함하는 SpringBootApplication 어노테이션이 모든 Bean 객체를 생성해줌!
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
    }
}
```

<br>

## 3부. @Autowired

> 필요한 의존 객체의 "타입"에 해당하는 빈을 찾아 주입한다.

### @Autowired

* required: default - true (못 찾으면 구동 실패)

### 사용 가능한 위치

* constructor (스프링 4.3 이후부터 생략 가능)
  * 빈을 만들 때 생성자에 parameter로 넘겨지는 bean이 존재하지 않으면 안됨
* setter
* field

### 경우의 수 (use case)

* 해당 타입의 빈이 없는 경우
* 해당 타입의 빈이 한 개인 경우
* 해당 타입의 빈이 여러 개인 경우
  * 빈 이름으로 시도
    * 같은 이름의 빈 찾으면 해당 빈 사용
    * 같은 이름 못 찾으면 실패

### 같은 타입의 빈이 여러개 일 때

* **@Primary**
  * 그나마 가장 추천!
* 해당 타입의 빈 모두 주입
  * `List<BookRepository> bookRepositoies;`
* @Qualifier (빈 이름으로 주입)
  * TypeSafe 하지 않으므로 @Primary 어노테이션을 더 추천

### 동작 원리

* Bean LifeCycle
  * Bean initialization
* BeanPostProcessor
  Bean을 만든 이후에 Bean initialization 라는 라이프사이클이 있음
  Bean Initialization 이전/이후에 부가적인 작업을 하기 위한 Life Cycle Callback이 있는데 그것이 BeanPostProcessor
  * @PostConstruct 어노테이션
    라이프사이클 콜백, InitializingBean's after PropertiesSet
    implements ApplicationRunner 보다 더 빠르게 실행됨 (어플리케이션 구동 중에 실행)
    * <-> ApplicationRunner
      ApplicationRunner는 Spring이 모든 Initialization이 끝나고 어플리케이션 구동이 끝난 다음에 실행
  * 새로 만든 인스턴스를 수정할 수 있는 라이프 사이클 인터페이스
  * Initialization 후에 처리 (아래의 Spring Lifecycle 12번 단계에서 해줌)
  * BeanFactory가 내부의 BeanPostProcessor를 찾음
* AutowiredAnnotationBeanPostProcessor
  * 스프링이 제공하는 @Autowired와 @Value 어노테이션 그리고 JSR-330의 @Inject 어노테이션을 지원하는 어노테이션 처리기
  * Initialization 전에 처리 (아래의 Spring Lifecycle 11번 단계에서 해줌)
  * https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html

### [BeanFactory Interface](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html)

> Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is:
>
> 1. BeanNameAware's `setBeanName`
> 2. BeanClassLoaderAware's `setBeanClassLoader`
> 3. BeanFactoryAware's `setBeanFactory`
> 4. EnvironmentAware's `setEnvironment`
> 5. EmbeddedValueResolverAware's `setEmbeddedValueResolver`
> 6. ResourceLoaderAware's `setResourceLoader` (only applicable when running in an application context)
> 7. ApplicationEventPublisherAware's `setApplicationEventPublisher` (only applicable when running in an application context)
> 8. MessageSourceAware's `setMessageSource` (only applicable when running in an application context)
> 9. ApplicationContextAware's `setApplicationContext` (only applicable when running in an application context)
> 10. ServletContextAware's `setServletContext` (only applicable when running in a web application context)
> 11. `postProcessBeforeInitialization` methods of BeanPostProcessors
> 12. InitializingBean's `afterPropertiesSet`
> 13. a custom init-method definition
> 14. `postProcessAfterInitialization` methods of BeanPostProcessors
>
> On shutdown of a bean factory, the following lifecycle methods apply:
>
> 1. `postProcessBeforeDestruction` methods of DestructionAwareBeanPostProcessors
> 2. DisposableBean's `destroy`
> 3. a custom destroy-method definition

<br>

## 4부. @Component와 Component Scan

### 컨포넌트 스캔 주요 기능

- **스캔 위치 설정**
  
  - scanBasePackages
  - scanBasePackageClasses
  - SpringBoot는 SpringBootApplication 어노테이션안에 존재함
- **필터**
  어떤 애노테이션을 스캔 할지 또는 하지 않을지

  ```java
  @ComponentScan(excludeFilters = { 
    @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
  	@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) 
  })
  ```
  

### Component Scan의 대상들 - @Component

- @Repository

- @Service

- @Controller

-  @Configuration


### 동작 원리

- @ComponentScan은 스캔할 패키지와 애노테이션에 대한 정보
- 실제 스캐닝은 ConfigurationClassPostProcessor라는 BeanFactoryPostProcessor에 의해 처리 됨. 
  -  다른 모든 빈들을 만들기 이전에 실행

### Functional을 사용한 빈 등록

Spring5 이상에서 등장한 방법
Reflection, Proxy 같은 기법을 사용하지 않으므로 구동 성능에 영향을 주지 않음
모든 Component를 등록하는건 엄청난 설정 파일을 만들게 될 것이기 때문에 대체는 어려움
다른 패키지의 Bean을 등록하는 경우를 대체하기에는 나쁘지 않음


```java
public static void main(String[] args) {
        new SpringApplicationBuilder()
          .sources(Demospring51Application.class)
          .initializers(
          (ApplicationContextInitializer<GenericApplicationContext>) applicationContext -> {
            applicationContext.registerBean(MyBean.class); 
          })
          .run(args);
}
```

