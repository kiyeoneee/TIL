# Clean Code ([Robert C. Martin](https://en.wikipedia.org/wiki/Robert_C._Martin))

## 목차

1. [깨끗한 코드](#1장-깨끗한-코드)

2. [의미 있는 이름](#2장-의미-있는-이름)

3. [함수](#3장-함수)

4. [주석](#4장-주석)

5. [형식 맞추기](#5장-형식-맞추기)

   

---

## 1장. 깨끗한 코드

### 보이스카우트 규칙

* 코드는 잘 짜기만 했을 때 끝나는 것이 아닌, 시간이 지나도 언제나 깨끗하게 유지해야 한다.
* 보이스카우트 규칙  
  ` 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.`

<br>

---

## 2장. 의미 있는 이름

### 의도를 분명히 밝혀라

이름을 지을 때 아래의 질문들을 고려해야 한다.

* 변수(혹은 함수나 클래스)의 존재 이유는?
* 수행 기능은?
* 사용 방법은?

**Bad**  

```java
public List<int[]> getThem() {
  List<int[]> list1 = new ArrayList<int[]>();
  for (int[] x : theList)
    if (x[0] == 4)
    	list1.add(x);
  return list1;
}
```

복잡한 코드는 아니지만  해당 메서드가 무엇을(them) 가져오는 것인지, List에 담기는 int[] 배열은 무슨 데이터인지, 4는 무슨 의미를 가지는지를 알 수 없다. 이 말은 곧 각 변수들의 정보를 모르는 경우 코드의 맥락을 완전히 이해 할 수 없다는 뜻이다.  
각 변수들의 정보를 모르더라도 이해할 수 있도록 아래와 같이 수정할 수 있다.

**Good**  

```java
public List<Cell> getFlaggedCells() {
  List<Cell> flaggedCells = new ArrayList<Cell>();
  for (Cell cell : gameBoard)
    if (cell.isFlagged())
      flaggedCells.add(cell);
  return flaggedCells;
}
```

<br>

### 그릇된 정보를 피하라

* 약어를 지양하자  
* 여러 계정을 그룹으로 묶을 때 List와 같은 특정 컨테이너의 사용을 지양하라 (e.g., **accountList -> Accounts**)  
* 네이밍은 서로 비슷한 이름을 사용하지 말자  
* 유사한 개념은 유사한 표기법을 사용하자, 일관성이 떨어지는 표기법은 그릇된 정보이다.  
* 다른 글자와 혼동되는 단일 알파벳을 피하자 (e.g., 소문자 L <-> 1, 대문자 I)

<br>

### 의미 있게 구분하라

한 scope에서 동일 이름을 사용할 수 없으니 컴파일러를 통과하기 위한 무의미한 철자 변경의 오류를 범하지 않도록 해야 한다. 무의미한 철자 변경의 대표적인 두가지 예시는 아래와 같다.    

* 연속된 숫자를 덧붙이기     
  **Bad :**

  ```java
  public static void copyChars(char a1[], char a2[])
  ```

  **Good :**  

  ```java
  public static void copyChars(char souce[], char destination[])
  ```


* 불용어(noise word) 추가    
  불용어란? 없어도 의미 전달에 영향이 없는 단어

  * 접두어 사용을 조심하자  
    a, an, the와 같은 접두어는 의미가 분명히 다를 때만 사용하도록 한다. (e.g., 모든 지역변수는 a 접두사 사용, 모든 함수 인수는 the 접두사 사용)  
  * 불용어를 사용하여 중복을 발생시키지 말자  
    product라는 클래스가 존재 할 때 ProductInfo, ProductData와 같은 개념이 구분되지 않는 클래스를 생성하여 중복을 발생시키지 않도록 한다. (e.g.,  Money & MoneyAccaount, CustomerInfo & Customer, AccountData & Account)


<br>

### 검색하기 쉬운 이름을 사용하라

* **상수**  
  상수값에 버그가 있을 경우 검색으로 찾아낼 수 없다. 그러나 상수값의 의미를 나타내는 변수로 정의하여 사용하면 검색에 용의하다.

* **변수**  
  알파벳 하나를 변수로 사용하면 검색이 어렵다. 

**Bad :**  

```java
int s = 0;
for (int i = 0; i < 30; i++) 
  s += i * 4;
```

**Good :**  

```java
int maxIndex = 30;
const int MULTIPLICATION_CONDITION = 4;
int sum = 0;
for (int i = 0; i < maxIndex; i++) // 하나의 메서드에서만 쓰이며, 다시 쓰이지 않는다면 한 문자 변수도 나쁘지 않다
  sum += i * MULTIPLICATION_CONDITION;
```

  <br>

### 인코딩을 피하라

* 헝가리식 표기법을 지양하라  
  과거 프로그래밍 언어는 변수 및 함수의 인자 이름 앞에 데이터 타입을 명시하는 헝가리식 표기법을 사용하였으나 현대의 프로그래밍 언어는 많은 컴파일러가 타입을 기억하고 강제하므로 네이밍 시 타입을 직접 명시하는 것을 피하는 것이 좋다. 오히려 아래와 같은 문제가 발생 할 수 있다.    

  ```java
  PhoneNumber phoneString; // 이러한 경우 타입이 바뀌게 되었을 때 변수명도 바꿔주어야 하는 문제가 생긴다.
  ```

* 멤버 변수 접두어  
  멤버 변수임을 명시하기 위해 "m_" 접두어를 붙이는 것을 지양하고 클래승와 함수는 접두어가 필요없을 정도로 작게 구현해야 한다.  

* 인코딩이 필요한 경우?  
  Abstract Factory를 구현하는 경우, 인터페이스 클래스 이름보다는 구현 클래스의 이름을 인코딩 하는 것이 좋다.  
  **Bad :**

  ```java
  public interface IShapeFactory;  // 인터페이스 클래스
  public class ShapeFactory;  // 구현 클래스
  ```

  **Good :**  

  ```java
  public interface ShapeFactory;  // 인터페이스 클래스
  public class ShapeFactoryImp;  // 구현 클래스
  public class CShapeFactory;  // 구현 클래스    
  ```

<br>

### 클래스 이름

* 동사가 들어가지 않는 명사/명사구가 적합하다.
* 불용어를 지양하자 (e.g., Manager, Processor, Data, Info)

**Good :**  

```java
public class Customer
public class WikiPage
public class AddressParser
```

<br>

### 메서드 이름

* 동사/동사구가 적합하다.

* 접근자(Accessor), 변경자(Mutator), 조건자(Predicate)는 [javabean 표준](https://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html)에 따라 get, set, is를 붙인다.  
  e.g.,  

  ```java
  String name = employee.getName();
  customer.setName("mike");
  if (paycheck.isPosted());
  ```

  

* 생성자의 중복정의 시 정적 팩토리 메서드를 사용한다. (이때, 생성자 사용을 제한하려면 해당 생성자를 private으로 사용한다.)    

  - 해당 내용의 상세한 특징은 Effective Java 3/E 기준 Item1을 참고한다. 

  **Bad :**  

  ```java
  Complex fulcrumPoint = new Complex(23.0);
  ```

  **Good :**

  ```java
  Complex fulcrumPoint = Complex.FromRealNumber(23.0);
  ```
  
  <br>

---

## 3장. 함수

### 작게 만들어라!

작게의 기준은 무엇일까?

* 블록과 들여쓰기  
  if/else/switch 문 등에 들어가는 블록은 한 줄이며 indent는 2단을 넘어서면 안된다.  
  적절한 메서드명을 가지는 메서드를 호출하는 방식을 통해 이를 충족시킨다.

<br>

### 한 가지만 해라!

**함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.**

<br>

### 함수 당 추상화 수준은 하나로!

함수 내에 추상화 수준이 섞이면 특정 표현이 근본 개념인지 세부사항인지 구분하기 어려워진다.  

<br>

### Switch 문

Switch문의 문제점

1. 함수가 길어진다
2. '한 가지' 작업만 수행하지 않는다.
3. Single Response Principle를 위반한다.
4. Open Closed Principle을 위반한다.

Switch문은 다형적 객체를 생성하는 코드안에서만 사용하도록 해야 한다.

<br>

### 함수 인수

테스트 코드 관점에서도 인자가 많을수록 테스트를 위한 유효한 인자를 만들어야 하는 문제가 생긴다.  
가장 이상적인 인수 개수는 0개, 최대 3개. 하지만 적을수록 좋다. 줄이자 줄이자!

* 많이 쓰는 단항 형식  

* 플래그 인수

* 이항 함수

* 삼항 함수

* 인수 객체 

* 인수 목록

* 동사와 키워드

<br>

### 부수 효과를 일으키지 마라!

함수는 꼭 한 가지 기능만을 한다.  
부수 효과로 발생 가능한 문제? 

* Temporal Coupling  
* Order Dependency

<br>

### 오류 코드보다 예외를 사용하라!  

오류코드의 문제점  

* 호출자는 오류 코드를 바로 처리해야 한다.
* 의존성 자석 : 오류 코드의 수정/추가/삭제가 일어날 경우 처리 코드도 수정해야 한다

**Try/Catch 블록 뽑아내기**  
오류처리도 한 가지 작업임을 인지하고 오류 처리 함수를 분리하도록 한다.

<br>

### 반복하지 마라!

반복되는 코드가 다른 코드와 섞이면 모양이 달라지면서 중복이 잘 드러나지 않게 되어 수정이 일어날 때 오류가 발생할 확률이 높아진다.

중복을 없애거나 제어 할 목적의 원칙과 기법들

* 관계형 데이터베이스에 정규 형식을 만듦
* 객체지향 프로그래밍 - 코드를 부모 클래스로 몰아 중복을 없앰
* 구조적 프로그래밍
* AOP(Aspect Oriented Programming) - Spring의 핵심 개념 중 하나로 부가기능의 모듈화 (하단 링크들 참고)
* COP(Component Oriented Programming) - 기존 시스템이나 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용프로그램을 만드는 소프트웨어 개발 방법론

<br>

### 구조적 프로그래밍

모든 함수와 함수 내 모든 블록에 entry와 exit이 하나만 존재해야 한다. 즉, return 문이 하나여야 한다. 루프 안에서 break, continue를 사용해서는 안 되며 goto는 절대로 안된다.

함수가 클 때만 이익을 제공하는 기법이다.  
함수가 작을때는 return, break, continue를 여러차례 사용해도 괜찮지만 goto는 작은 함수에서도 피해야 한다.

<br>

---

## 4장. 주석  

### 주석은 나쁜 코드를 보완하지 못한다

모듈이 지저분하다면 주석을 다는것이 아니라 코드를 정리해야 한다.

<br>

### 좋은 주석

* 법적인 주석
* 정보를 제공하는 주석  
  코드를 개선하면 없앨 수 있는 주석이다.
* 의도를 설명하는 주석  
  소스 코드의 알고리즘을 결정하게 된 의도를 설명하는 주석  
* 의미를 명료하게 밝히는 주석  
  인수나 반환값이 변경하지 못하는 코드일 경우 의미를 명료하게 밝히는 주석 (이 또한 오류가 존재하더라도 확인이 어려워지니 고민하고 정확히 달도록 해야 한다.)
* 결과를 경고하는 주석
* TODO 주석  
* 중요성을 강조하는 주석
* 공개 API에서 Javadocs

<br>

### 나쁜 주석

* 주절거리는 주석
* 같은 이야기를 중복하는 주석
* 오해할 여지가 있는 주석
* 의무적으로 다는 주석
* 이력을 기록하는 주석
* 있으나 마나 한 주석
* 무서운 잡음
* 함수나 변수로 표현할 수 있다면 주석을 달지 마라
* 위치를 표시하는 주석
* 닫는 괄호에 다는 주석
* 공로를 돌리거나 저자를 표시하는 주석
* 주석으로 처리한 코드
* HTML 주석
* 전역정보
* 너무 많은 정보
* 모호한 관계  
  주석이 코드의 부족한 설명 외에 도메인 지식이 있어 추가적인 설명이 필요한 경우는 최악
* 함수 헤더
* 비공개 코드에서 Javadocs

<br>

---

## 5장. 형식 맞추기

맨 처음 잡아놓은 코드의 스타일과 가독성은 유지보수 용이성과 확정성에 계속 영향을 미친다.

<br>

### 적절한 행 길이를 유지하라

* 신문 기사처럼 작성하라  
  소스 파일은 고차원 개념/알고리즘 -> 저차원 함수와 세부 내역 순으로 아래로 내려갈수록 의도를 세세하게 표현
* 개념은 빈 행으로 분리하라
* 세로 밀집도  
  서로 밀접한 코드 행은 세로로 가까이 놓여야 함
* 수직 거리  
  **변수 선언** - 사용하는 위치에 최대한 가까이 선언  
  **인스턴스 변수** - 클래스의 맨 처음에 선언, 변수 간에 세로로 거리를 두지 않음  
  **종속 함수** - 한 함수에서 호출하는 다른 함수는 세로로 가까이 배치 (함수 -> 호출되는 함수 순서)  
  **개념적 유사성** - 친화도가 높을수록 코드를 가까이 배치 (한 함수가 다른 함수를 호출하는 직접적인 종속성, 변수와 그 변수를 사용하는 함수, 명명법이 똑같거나 기능이 같은 함수)
* 세로 순서  
  함수 호출 종속성은 아래 방향으로 유지, 자연스럽게 소스 코드 모듈이 고차원 -> 저차원으로 기술

<br>

### 가로 형식 맞추기

Max 120자

* 가로 공백과 밀집도  
  공백을 통해 개념을 분리 (e.g., 할당 연산자, parameter 분리를 위한 ", ")  
  연산자 우선순위 구분을 위한 공백 추가
* 가로 정렬  
  정렬이 필요할 정도로 목록이 길다면 클래스를 쪼개는 방법을 고려
* 들여쓰기  
  scope로 이뤄진 계층을 표현하기 위해 사용  
  **1줄의 if/while/함수**도 꼭 {} 괄호를 사용하며 들여쓰기를 사용
* 가짜 범위  
  **빈 while/for문은 다음 행에 세미콜론을 들여써서 작성**

<br>

### 팀 규칙

팀에 속해 있다면?  
각자의 선호하는 규칙 < 팀 규칙

<br>

