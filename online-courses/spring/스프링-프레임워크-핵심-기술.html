<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>스프링 프레임워크 핵심기술 | Today kiyeoneee Learned</title>
    <meta name="generator" content="VuePress 1.6.0">
    
    <meta name="description" content="What kiyeoneee learned everyday">
    <link rel="preload" href="/TIL/assets/css/0.styles.25cf7e1a.css" as="style"><link rel="preload" href="/TIL/assets/js/app.14df79b1.js" as="script"><link rel="preload" href="/TIL/assets/js/2.dce8ba1c.js" as="script"><link rel="preload" href="/TIL/assets/js/8.130adf09.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.4f5ca765.js"><link rel="prefetch" href="/TIL/assets/js/11.8c375806.js"><link rel="prefetch" href="/TIL/assets/js/12.b481e600.js"><link rel="prefetch" href="/TIL/assets/js/13.f20868f4.js"><link rel="prefetch" href="/TIL/assets/js/14.41e7de9c.js"><link rel="prefetch" href="/TIL/assets/js/15.0e8a7359.js"><link rel="prefetch" href="/TIL/assets/js/16.203af499.js"><link rel="prefetch" href="/TIL/assets/js/17.063a3e76.js"><link rel="prefetch" href="/TIL/assets/js/18.97a8642a.js"><link rel="prefetch" href="/TIL/assets/js/19.402f271c.js"><link rel="prefetch" href="/TIL/assets/js/20.7018a74a.js"><link rel="prefetch" href="/TIL/assets/js/21.374cbc95.js"><link rel="prefetch" href="/TIL/assets/js/22.b10e5b32.js"><link rel="prefetch" href="/TIL/assets/js/23.8c73a2d0.js"><link rel="prefetch" href="/TIL/assets/js/24.a6b3b327.js"><link rel="prefetch" href="/TIL/assets/js/25.67310368.js"><link rel="prefetch" href="/TIL/assets/js/26.0cc3dc23.js"><link rel="prefetch" href="/TIL/assets/js/27.37dbddf6.js"><link rel="prefetch" href="/TIL/assets/js/28.25bf1a71.js"><link rel="prefetch" href="/TIL/assets/js/29.5178dc1b.js"><link rel="prefetch" href="/TIL/assets/js/3.54a487f9.js"><link rel="prefetch" href="/TIL/assets/js/30.900f1a49.js"><link rel="prefetch" href="/TIL/assets/js/31.5acadd72.js"><link rel="prefetch" href="/TIL/assets/js/32.32847f7d.js"><link rel="prefetch" href="/TIL/assets/js/33.d04d65df.js"><link rel="prefetch" href="/TIL/assets/js/34.a72ae435.js"><link rel="prefetch" href="/TIL/assets/js/35.161fd7dc.js"><link rel="prefetch" href="/TIL/assets/js/36.754771e8.js"><link rel="prefetch" href="/TIL/assets/js/37.e070245d.js"><link rel="prefetch" href="/TIL/assets/js/38.06a44a05.js"><link rel="prefetch" href="/TIL/assets/js/39.275c570e.js"><link rel="prefetch" href="/TIL/assets/js/4.30442eb7.js"><link rel="prefetch" href="/TIL/assets/js/40.d597ea7b.js"><link rel="prefetch" href="/TIL/assets/js/41.245be6d0.js"><link rel="prefetch" href="/TIL/assets/js/42.12baffdd.js"><link rel="prefetch" href="/TIL/assets/js/43.86f1dc16.js"><link rel="prefetch" href="/TIL/assets/js/44.db7e6df7.js"><link rel="prefetch" href="/TIL/assets/js/45.203b2bc7.js"><link rel="prefetch" href="/TIL/assets/js/46.e9df3ac1.js"><link rel="prefetch" href="/TIL/assets/js/47.deadd21a.js"><link rel="prefetch" href="/TIL/assets/js/48.b70a2df0.js"><link rel="prefetch" href="/TIL/assets/js/49.1a4d181d.js"><link rel="prefetch" href="/TIL/assets/js/5.a34725ae.js"><link rel="prefetch" href="/TIL/assets/js/50.fa9d44cb.js"><link rel="prefetch" href="/TIL/assets/js/51.3202ad00.js"><link rel="prefetch" href="/TIL/assets/js/52.a6b1fe41.js"><link rel="prefetch" href="/TIL/assets/js/53.dd35c8d1.js"><link rel="prefetch" href="/TIL/assets/js/54.44b419f9.js"><link rel="prefetch" href="/TIL/assets/js/55.e2e2942a.js"><link rel="prefetch" href="/TIL/assets/js/56.fc1b4e3e.js"><link rel="prefetch" href="/TIL/assets/js/57.3aad11c0.js"><link rel="prefetch" href="/TIL/assets/js/58.fcd4daa5.js"><link rel="prefetch" href="/TIL/assets/js/59.d043979e.js"><link rel="prefetch" href="/TIL/assets/js/6.a0757fc0.js"><link rel="prefetch" href="/TIL/assets/js/60.58261ba7.js"><link rel="prefetch" href="/TIL/assets/js/61.3e59b22b.js"><link rel="prefetch" href="/TIL/assets/js/62.b1ac5ae1.js"><link rel="prefetch" href="/TIL/assets/js/63.01eebdae.js"><link rel="prefetch" href="/TIL/assets/js/64.5c3d4686.js"><link rel="prefetch" href="/TIL/assets/js/65.1c655cd7.js"><link rel="prefetch" href="/TIL/assets/js/7.112c04ff.js"><link rel="prefetch" href="/TIL/assets/js/9.b12d813d.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.25cf7e1a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><!----> <span class="site-name">Today kiyeoneee Learned</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/kiyeoneee" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://kyeoneee.tistory.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Tech Blog
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/kiyeoneee" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://kyeoneee.tistory.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Tech Blog
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Books</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/TIL/book/clean-code" class="sidebar-heading clickable open"><span>Clean Code</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/TIL/book/clean-code/2-의미있는-이름.html" class="sidebar-link">2장. 의미있는 이름</a></li><li><a href="/TIL/book/clean-code/3-함수.html" class="sidebar-link">3장. 함수</a></li><li><a href="/TIL/book/clean-code/4-주석.html" class="sidebar-link">4장. 주석</a></li><li><a href="/TIL/book/clean-code/5-형식-맞추기.html" class="sidebar-link">5장. 형식 맞추기</a></li><li><a href="/TIL/book/clean-code/6-객체와-자료-구조.html" class="sidebar-link">6장. 객체와 자료 구조</a></li><li><a href="/TIL/book/clean-code/7-오류-처리.html" class="sidebar-link">7장. 오류 처리</a></li><li><a href="/TIL/book/clean-code/8-경계.html" class="sidebar-link">8장. 경계</a></li><li><a href="/TIL/book/clean-code/9-단위테스트.html" class="sidebar-link">9장. 단위 테스트</a></li><li><a href="/TIL/book/clean-code/10-클래스.html" class="sidebar-link">10장. 클래스</a></li><li><a href="/TIL/book/clean-code/11-시스템.html" class="sidebar-link">11장. 시스템</a></li><li><a href="/TIL/book/clean-code/12-창발성.html" class="sidebar-link">12장. 창발성</a></li><li><a href="/TIL/book/clean-code/14-점진적-개선.html" class="sidebar-link">14장. 점진적 개선</a></li></ul></section></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="스프링-프레임워크-핵심기술"><a href="#스프링-프레임워크-핵심기술" class="header-anchor">#</a> 스프링 프레임워크 핵심기술</h1> <blockquote><p><strong>url</strong> : https://www.inflearn.com/course/spring-framework_core/dashboard
<strong>강사</strong> : 백기선</p> <p>스프링을 잘 모르면서 사용하다보니 이대로는 안되겠다 하는 시점들이 자주 찾아온다ㅠㅠ
더는 미룰 수 없어서 수강하는 스프링 프레임워크 핵심기술!</p></blockquote> <h1 id="_0-소개"><a href="#_0-소개" class="header-anchor">#</a> 0. 소개</h1> <h4 id="스프링이란"><a href="#스프링이란" class="header-anchor">#</a> 스프링이란?</h4> <ul><li>소규모 애플리케이션 또는 기업용 애플리케이션을 자바로 개발하는데 있어 유용하고 편리한 기능을 제공하는 프레임워크</li></ul> <h3 id="디자인-철학"><a href="#디자인-철학" class="header-anchor">#</a> 디자인 철학</h3> <ul><li>모든 선택은 개발자의 몫</li> <li>다양한 관점을 지향하여 유연성을 높임</li> <li>하위 호환성을 지킴</li> <li>API를 신중하게 설계</li> <li>높은 수준의 코드 지향</li></ul> <br> <h1 id="_1-ioc-컨테이너와-빈"><a href="#_1-ioc-컨테이너와-빈" class="header-anchor">#</a> 1. IoC 컨테이너와 빈</h1> <h2 id="_1부-스프링-ioc-컨테이너와-빈"><a href="#_1부-스프링-ioc-컨테이너와-빈" class="header-anchor">#</a> 1부. 스프링 IoC 컨테이너와 빈</h2> <h3 id="ioc란"><a href="#ioc란" class="header-anchor">#</a> IoC란?</h3> <blockquote><p>의존 관계 주입 ( Inversion of Control )
한 클래스에서 사용할 의존 객체를 생성자를 사용해 직접 만들어서 사용하는 것이 아니라, 주입받아서 사용하는 방법</p></blockquote> <h3 id="ioc-컨테이너"><a href="#ioc-컨테이너" class="header-anchor">#</a> IoC 컨테이너</h3> <ul><li>BeanFactory interface가 가장 핵심</li> <li>어플리케이션 컴포넌트의 중앙 저장소</li> <li>빈 설정 소스로 부터 빈 정의를 읽어들이고, 빈을 구성하고 제공</li></ul> <h3 id="bean"><a href="#bean" class="header-anchor">#</a> Bean</h3> <ul><li><p>스프링 IoC 컨테이너가 관리하는 객체</p></li> <li><p>장점</p> <ul><li>의존성 관리</li> <li>스코프
<ul><li>싱글톤 : 하나만 만들어서</li> <li>프로토타입 : 매번 다른 객체</li></ul></li> <li>라이프사이클 인터페이스</li></ul></li></ul> <h4 id="applicationcontext"><a href="#applicationcontext" class="header-anchor">#</a> ApplicationContext</h4> <p>실질적으로 우리가 가장 많이 사용하게 될 BeanFactory
BeanFactory를 상속하여 기본적인 BeanFactory의 기능을 수행하면서 추가적인 기능들을 제공</p> <ul><li>BeanFactory</li> <li>메세지 소스 처리 기능 (i18n)</li> <li>이벤트 발행 기능</li> <li>리소스 로딩 기능</li> <li>...</li></ul> <br> <h2 id="_2부-applicationcontext와-다양한-빈-설정-방법"><a href="#_2부-applicationcontext와-다양한-빈-설정-방법" class="header-anchor">#</a> 2부. ApplicationContext와 다양한 빈 설정 방법</h2> <h3 id="bean을-정의하는-방법은-어노테이션-외에도-xml-파일로-가능"><a href="#bean을-정의하는-방법은-어노테이션-외에도-xml-파일로-가능" class="header-anchor">#</a> Bean을 정의하는 방법은 어노테이션 외에도 xml 파일로 가능</h3> <p>application.xml</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>소문자 시작, camelCase<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>해당 클라스 package.ClassName<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>상속 받을 클래스 내부에 인스턴스 변수 명<span class="token punctuation">&quot;</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>다른 bean id<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>application.java</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;application.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>beanDefinitionNames<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">BookService</span> bookService <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BookService</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;bookService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>이러한 방법은 매우 불편하다!</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>스프링 컨테이너가 관리할 package<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>근데 java로 컨피그 파일을 만들 수는 없을까?</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token comment">//@ComponentScan(basePackageClasses = Application.class)  </span>
<span class="token comment">// 이 클래스가 위치한 곳부터 component 스캐닝을 해라</span>
<span class="token comment">// ComponentScan 어노테이션을 달면 아래의 bean 정의는 모두 삭제해도 됨</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationConfig</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">BookRepository</span> <span class="token function">bookRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BookRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">BookService</span> <span class="token function">bookService</span><span class="token punctuation">(</span><span class="token class-name">BookRepository</span> bookRepository<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BookService</span><span class="token punctuation">(</span>bookRepository<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">ApplicationConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> beanDefinitionNames <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBeanDefinitionNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>beanDefinitionNames<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BookService</span> bookService <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BookService</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">&quot;bookService&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bookService<span class="token punctuation">.</span>bookRepository <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>SpringBoot를 사용한다면 이러한 bean 정의를 모두 생략할 수 있다.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// ComponentScan 어노테이션을 포함하는 SpringBootApplication 어노테이션이 모든 Bean 객체를 생성해줌!</span>
<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><br> <h2 id="_3부-autowired"><a href="#_3부-autowired" class="header-anchor">#</a> 3부. @Autowired</h2> <blockquote><p>필요한 의존 객체의 &quot;타입&quot;에 해당하는 빈을 찾아 주입한다.</p></blockquote> <h3 id="autowired"><a href="#autowired" class="header-anchor">#</a> @Autowired</h3> <ul><li>required: default - true (못 찾으면 구동 실패)</li></ul> <h3 id="사용-가능한-위치"><a href="#사용-가능한-위치" class="header-anchor">#</a> 사용 가능한 위치</h3> <ul><li>constructor (스프링 4.3 이후부터 생략 가능)
<ul><li>빈을 만들 때 생성자에 parameter로 넘겨지는 bean이 존재하지 않으면 안됨</li></ul></li> <li>setter</li> <li>field</li></ul> <h3 id="경우의-수-use-case"><a href="#경우의-수-use-case" class="header-anchor">#</a> 경우의 수 (use case)</h3> <ul><li>해당 타입의 빈이 없는 경우</li> <li>해당 타입의 빈이 한 개인 경우</li> <li>해당 타입의 빈이 여러 개인 경우
<ul><li>빈 이름으로 시도
<ul><li>같은 이름의 빈 찾으면 해당 빈 사용</li> <li>같은 이름 못 찾으면 실패</li></ul></li></ul></li></ul> <h3 id="같은-타입의-빈이-여러개-일-때"><a href="#같은-타입의-빈이-여러개-일-때" class="header-anchor">#</a> 같은 타입의 빈이 여러개 일 때</h3> <ul><li><strong>@Primary</strong> <ul><li>그나마 가장 추천!</li></ul></li> <li>해당 타입의 빈 모두 주입
<ul><li><code>List&lt;BookRepository&gt; bookRepositoies;</code></li></ul></li> <li>@Qualifier (빈 이름으로 주입)
<ul><li>TypeSafe 하지 않으므로 @Primary 어노테이션을 더 추천</li></ul></li></ul> <h3 id="동작-원리"><a href="#동작-원리" class="header-anchor">#</a> 동작 원리</h3> <ul><li><p><img src="/TIL/assets/img/vue_component_communication_same_level2.a02b9de3.png" alt="같은 컴포넌트 레벨 간의 통신 방법2"></p></li> <li><p>BeanPostProcessor
Bean을 만든 이후에 Bean initialization 라는 라이프사이클이 있음
Bean Initialization 이전/이후에 부가적인 작업을 하기 위한 Life Cycle Callback이 있는데 그것이 BeanPostProcessor</p> <ul><li>@PostConstruct 어노테이션
라이프사이클 콜백, InitializingBean's after PropertiesSet
implements ApplicationRunner 보다 더 빠르게 실행됨 (어플리케이션 구동 중에 실행)
<ul><li>&lt;-&gt; ApplicationRunner
ApplicationRunner는 Spring이 모든 Initialization이 끝나고 어플리케이션 구동이 끝난 다음에 실행</li></ul></li> <li>새로 만든 인스턴스를 수정할 수 있는 라이프 사이클 인터페이스</li> <li>Initialization 후에 처리 (아래의 Spring Lifecycle 12번 단계에서 해줌)</li> <li>BeanFactory가 내부의 BeanPostProcessor를 찾음</li></ul></li> <li><p>AutowiredAnnotationBeanPostProcessor</p> <ul><li>스프링이 제공하는 @Autowired와 @Value 어노테이션 그리고 JSR-330의 @Inject 어노테이션을 지원하는 어노테이션 처리기</li> <li>Initialization 전에 처리 (아래의 Spring Lifecycle 11번 단계에서 해줌)</li> <li>https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html</li></ul></li></ul> <h3 id="beanfactory-interface"><a href="#beanfactory-interface" class="header-anchor">#</a> <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener noreferrer">BeanFactory Interface<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <blockquote><p>Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is:</p> <ol><li>BeanNameAware's <code>setBeanName</code></li> <li>BeanClassLoaderAware's <code>setBeanClassLoader</code></li> <li>BeanFactoryAware's <code>setBeanFactory</code></li> <li>EnvironmentAware's <code>setEnvironment</code></li> <li>EmbeddedValueResolverAware's <code>setEmbeddedValueResolver</code></li> <li>ResourceLoaderAware's <code>setResourceLoader</code> (only applicable when running in an application context)</li> <li>ApplicationEventPublisherAware's <code>setApplicationEventPublisher</code> (only applicable when running in an application context)</li> <li>MessageSourceAware's <code>setMessageSource</code> (only applicable when running in an application context)</li> <li>ApplicationContextAware's <code>setApplicationContext</code> (only applicable when running in an application context)</li> <li>ServletContextAware's <code>setServletContext</code> (only applicable when running in a web application context)</li> <li><code>postProcessBeforeInitialization</code> methods of BeanPostProcessors</li> <li>InitializingBean's <code>afterPropertiesSet</code></li> <li>a custom init-method definition</li> <li><code>postProcessAfterInitialization</code> methods of BeanPostProcessors</li></ol> <p>On shutdown of a bean factory, the following lifecycle methods apply:</p> <ol><li><code>postProcessBeforeDestruction</code> methods of DestructionAwareBeanPostProcessors</li> <li>DisposableBean's <code>destroy</code></li> <li>a custom destroy-method definition</li></ol></blockquote> <br> <h2 id="_4부-component와-component-scan"><a href="#_4부-component와-component-scan" class="header-anchor">#</a> 4부. @Component와 Component Scan</h2> <h3 id="컨포넌트-스캔-주요-기능"><a href="#컨포넌트-스캔-주요-기능" class="header-anchor">#</a> 컨포넌트 스캔 주요 기능</h3> <ul><li><p><strong>스캔 위치 설정</strong></p> <ul><li>scanBasePackages</li> <li>scanBasePackageClasses</li> <li>SpringBoot는 SpringBootApplication 어노테이션안에 존재함</li></ul></li> <li><p><strong>필터</strong>
어떤 애노테이션을 스캔 할지 또는 하지 않을지</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span> 
  <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">TypeExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">AutoConfigurationExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li></ul> <h3 id="component-scan의-대상들-component"><a href="#component-scan의-대상들-component" class="header-anchor">#</a> Component Scan의 대상들 - @Component</h3> <ul><li><p>@Repository</p></li> <li><p>@Service</p></li> <li><p>@Controller</p></li> <li><p>@Configuration</p></li></ul> <h3 id="동작-원리-2"><a href="#동작-원리-2" class="header-anchor">#</a> 동작 원리</h3> <ul><li>@ComponentScan은 스캔할 패키지와 애노테이션에 대한 정보</li> <li>실제 스캐닝은 ConfigurationClassPostProcessor라는 BeanFactoryPostProcessor에 의해 처리 됨.
<ul><li>다른 모든 빈들을 만들기 이전에 실행</li></ul></li></ul> <h3 id="functional을-사용한-빈-등록"><a href="#functional을-사용한-빈-등록" class="header-anchor">#</a> Functional을 사용한 빈 등록</h3> <p>Spring5 이상에서 등장한 방법
Reflection, Proxy 같은 기법을 사용하지 않으므로 구동 성능에 영향을 주지 않음
모든 Component를 등록하는건 엄청난 설정 파일을 만들게 될 것이기 때문에 대체는 어려움
다른 패키지의 Bean을 등록하는 경우를 대체하기에는 나쁘지 않음</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">SpringApplicationBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">sources</span><span class="token punctuation">(</span><span class="token class-name">Demospring51Application</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">initializers</span><span class="token punctuation">(</span>
          <span class="token punctuation">(</span><span class="token class-name">ApplicationContextInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GenericApplicationContext</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> applicationContext <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            applicationContext<span class="token punctuation">.</span><span class="token function">registerBean</span><span class="token punctuation">(</span><span class="token class-name">MyBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><br> <h2 id="_5부-bean의-scope"><a href="#_5부-bean의-scope" class="header-anchor">#</a> 5부. Bean의 Scope</h2> <h3 id="scope"><a href="#scope" class="header-anchor">#</a> Scope</h3> <ul><li>Singleton</li> <li>Prototype : 매번 새로운 인스턴스를 생성해서 사용
<ul><li>Request</li> <li>Session</li> <li>WebSocket</li> <li>...</li></ul></li></ul> <h3 id="scope가-다른-빈을-참조하게-되면"><a href="#scope가-다른-빈을-참조하게-되면" class="header-anchor">#</a> Scope가 다른 빈을 참조하게 되면?</h3> <ul><li><p>Prototype Bean이 Singleton Bean을 참조하면</p> <ul><li>아무 문제 없음</li></ul></li> <li><p>Singleton Bean이 Prototype Bean을 참조하면 (Long-run 하는 인스턴스가 짧은 생명주기의 인스턴를 주입받게 되면)</p> <ul><li><p>Singleton Bean 내의 Prototype Bean은 처음 객체 생성시에 할당된 instance 그대로</p></li> <li><p>업데이트 하려면?</p> <ul><li><p>scoped-proxy
https://en.wikipedia.org/wiki/Proxy_pattern
<code>@Scope(value = &quot;prototype&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)</code></p></li> <li><p>Object-Provider</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// Prototype 생명주기의 Proto를 사용한다면?</span>
<span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> <span class="token class-name">ObjectProvider</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Proto</span><span class="token punctuation">&gt;</span></span> proto<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">Proto</span> <span class="token function">getProto</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 단점 : spring 코드가 포함되게 됨</span>
    <span class="token keyword">return</span> proto<span class="token punctuation">.</span><span class="token function">getIfAvailable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>Provider (표준)</li></ul></li></ul></li></ul></li></ul> <h3 id="singleton-객체-사용히-주의할-점"><a href="#singleton-객체-사용히-주의할-점" class="header-anchor">#</a> Singleton 객체 사용히 주의할 점</h3> <ul><li>ThreadSafe 한 방법으로 코딩해야 함</li> <li>Property가 공유</li> <li>ApplicationContext 초기 구동시 인스턴스 생성</li></ul> <br> <h2 id="_6부-environment-1부-profile"><a href="#_6부-environment-1부-profile" class="header-anchor">#</a> 6부. Environment 1부 - Profile</h2> <h3 id="applicationcontext-extends-environmentcapable"><a href="#applicationcontext-extends-environmentcapable" class="header-anchor">#</a> ApplicationContext extends EnvironmentCapable</h3> <ul><li>getEnvironment()</li></ul> <h3 id="profile"><a href="#profile" class="header-anchor">#</a> Profile</h3> <ul><li>Bean들의 그룹</li> <li>Environment(Interface)의 역할은 활성화할 프로파일 확인 및 설정</li></ul> <h3 id="profile-usecase"><a href="#profile-usecase" class="header-anchor">#</a> Profile Usecase</h3> <ul><li>테스트 환경에서는 A라는 Bean을 사용하고, 배포 환경에서는 B라는 Bean을 사용하고 싶다</li> <li>이 Bean은 모니터링 용도니까 테스트할 때는 필요가 없고, 배포할 때만 등록이 되면 좋겠다</li></ul> <h3 id="profile-정의하기"><a href="#profile-정의하기" class="header-anchor">#</a> Profile 정의하기</h3> <ul><li>Class에 정의
<ul><li>@Configuration @Profile(&quot;test&quot;)</li> <li>@Component @Profile(&quot;test&quot;)</li></ul></li> <li>메서드에 정의 (Configuration 내에서 Bean 정의 시)
<ul><li>@Bean  @Profile(&quot;test&quot;)</li></ul></li></ul> <h3 id="profile-설정하기"><a href="#profile-설정하기" class="header-anchor">#</a> profile 설정하기</h3> <ul><li>-Dspring.profiles.active=&quot;test,A,B,...&quot;</li> <li>@ActiveProfiles (테스트용)</li></ul> <h3 id="프로파일-표현식"><a href="#프로파일-표현식" class="header-anchor">#</a> 프로파일 표현식</h3> <ul><li>! (not)
<ul><li>@Profile(&quot;!test&quot;)</li></ul></li> <li>&amp; (and)</li> <li>! (or)</li></ul> <br> <h2 id="_6부-environment-2부-property"><a href="#_6부-environment-2부-property" class="header-anchor">#</a> 6부. Environment 2부 - Property</h2> <h3 id="property"><a href="#property" class="header-anchor">#</a> Property</h3> <ul><li>다양한 방법으로 정의할 수 있는 설저앖</li> <li>Environment의 역할은 Property 소스 설정 및 property 값 가져오기</li></ul> <h3 id="property-우선순위"><a href="#property-우선순위" class="header-anchor">#</a> Property 우선순위</h3> <p>중복되는 값을 옵션으로 가지게 될 때 우선순위에 따라 설정됨</p> <ul><li>StandardServieEnvironment의 우선순위
<ul><li>ServletConfig 매개변수</li> <li>ServletContext 매개변수</li> <li>JNDI (java:comp/env/)</li> <li>JVM 시스템 프로퍼티 (-Dkey=&quot;value&quot;)</li> <li>JVM 시스템 환경 변수 (운영 체제 환경 변수)</li></ul></li></ul> <h3 id="propertysource"><a href="#propertysource" class="header-anchor">#</a> @PropertySource</h3> <ul><li>Environment를 통해 프로퍼티 추가하는 방법</li></ul> <h3 id="스프링-부트의-외부-설정-참고"><a href="#스프링-부트의-외부-설정-참고" class="header-anchor">#</a> 스프링 부트의 외부 설정 참고</h3> <ul><li>기본 프로퍼티 소스 지원 (application.properties)
@Value(&quot;${app.name}&quot;)</li> <li>프로파일까지 고려한 계층형 프로퍼티 우선 순위 제공</li></ul> <br> <h2 id="_7부-messagesource"><a href="#_7부-messagesource" class="header-anchor">#</a> 7부. MessageSource</h2> <p>국제화 (i18n) 기능을 제공하는 인터페이스
Spring framework를 사용 할 때는 bean을 등록해줘야 하지만, SpringBoot는 ResourceBundleMessageSource 가 기본으로 로딩 됨</p> <h3 id="applicationcontext-extends-messagesource"><a href="#applicationcontext-extends-messagesource" class="header-anchor">#</a> ApplicationContext extends MessageSource</h3> <ul><li>getMessage(String code, Object[] args, String, default, Locale, Ioc)</li> <li>...</li></ul> <h3 id="스프링-부트를-사용한다면-별다른-설정-필요없이-messages-properties-사용할-수-있음"><a href="#스프링-부트를-사용한다면-별다른-설정-필요없이-messages-properties-사용할-수-있음" class="header-anchor">#</a> 스프링 부트를 사용한다면 별다른 설정 필요없이 messages.properties 사용할 수 있음</h3> <ul><li>messages.properties</li> <li>messages_ko_kr.properties (messages.ko_KR.properties)</li></ul> <h3 id="reloading-기능이-있는-메세지-소스-사용하기"><a href="#reloading-기능이-있는-메세지-소스-사용하기" class="header-anchor">#</a> Reloading  기능이 있는 메세지 소스 사용하기</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">MessageSource</span> <span class="token function">messageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token class-name">ReloadableResourceBundleMessageSource</span> messageSource
            <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReloadableResourceBundleMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    messageSource<span class="token punctuation">.</span><span class="token function">setBasename</span><span class="token punctuation">(</span><span class="token string">&quot;classpath:/messages&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    messageSource<span class="token punctuation">.</span><span class="token function">setDefaultEncoding</span><span class="token punctuation">(</span><span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> messageSource<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><br> <h2 id="_8부-applicationeventpublisher"><a href="#_8부-applicationeventpublisher" class="header-anchor">#</a> 8부. ApplicationEventPublisher</h2> <blockquote><p>이벤트 프로그래밍에 필요한 인터페이스 제공
옵저버 패턴 구현체</p></blockquote> <h3 id="applicationcontext-extends-applicationeventpublisher"><a href="#applicationcontext-extends-applicationeventpublisher" class="header-anchor">#</a> ApplicationContext extends ApplicationEventPublisher</h3> <ul><li>publicEvent(ApplicationEvent event)</li></ul> <h3 id="이벤트-만들기"><a href="#이벤트-만들기" class="header-anchor">#</a> 이벤트 만들기</h3> <ul><li>ApplicationEvent 상속</li> <li>스프링 4.2 부터는 이 클래스를 상속받지 않아도 이벤트로 사용할 수 있다.</li></ul> <h3 id="이벤트-발생-시키는-방법"><a href="#이벤트-발생-시키는-방법" class="header-anchor">#</a> 이벤트 발생 시키는 방법</h3> <ul><li>ApplicationEventPublisher.publishEvent();</li></ul> <h3 id="이벤트-처리하는-방법"><a href="#이벤트-처리하는-방법" class="header-anchor">#</a> 이벤트 처리하는 방법</h3> <ul><li>ApplicationListener&lt;이벤트&gt; 구현한 클래스 만들어서 빈으로 등록하기</li> <li>스프링 4.2 부터는 @EventListener를 사용해서 빈의 메소드에 사용할 수 있음</li> <li>기본적으로는 synchronized</li> <li>순서를 정하고 싶다면 @Order와 함께 사용</li> <li>비동기적으로 실행하고 싶다면 @Async와 함께 사용
<ul><li>Thread는 스케쥴링을 통해 실행되기 때문에 @Order 어노테이션이 의미가 없음</li></ul></li></ul> <h3 id="스프링이-제공하는-기본-이벤트"><a href="#스프링이-제공하는-기본-이벤트" class="header-anchor">#</a> 스프링이 제공하는 기본 이벤트</h3> <ul><li>ContextRefreshedEvent: ApplicationContext를 초기화 했더니 리프레시 했을 때 발생</li> <li>ContextStartedEvent: ApplicationContext를 start()하여 라이프사이클 빈들이 시작 신호를 받은 시점에 발생</li> <li>ContextStoppedEvent: ApplicationContext를 stop()하여 라이프사이클 빈들이 정지 신호를 받은 시점에 발생</li> <li>ContextClosedEvent: ApplicationContext를 close()하여 싱글톤 빈 소멸되는 시점에 발생</li> <li>RequestHandledEvent: HTTP 요청을 처리했을 때 발생</li></ul> <br> <h2 id="_9부-resourceloader"><a href="#_9부-resourceloader" class="header-anchor">#</a> 9부. ResourceLoader</h2> <blockquote><p>리소스를 읽어오는 기능을 제공하는 인터페이스
<code>ApplicationContext extends ResourceLoader</code></p></blockquote> <h3 id="리소스-읽어오기"><a href="#리소스-읽어오기" class="header-anchor">#</a> 리소스 읽어오기</h3> <ul><li>파일 시스템에서 읽어오기</li> <li>클래스패스에서 읽어오기</li> <li>URL로 읽어오기</li> <li>상대/절대 경로로 읽어오기</li></ul> <p><code>Resource getResource(java.lang.String location)</code></p> <br> <h1 id="_2-resource-validation"><a href="#_2-resource-validation" class="header-anchor">#</a> 2. Resource / Validation</h1> <h2 id="_1부-resource-추상화"><a href="#_1부-resource-추상화" class="header-anchor">#</a> 1부. Resource 추상화</h2> <blockquote><p>org.springframework.core.io.Resource</p></blockquote> <h3 id="특징"><a href="#특징" class="header-anchor">#</a> 특징</h3> <ul><li>java.net.URL을 추상화 한 것</li> <li>스프링 내부에서 많이 사용하는 인터페이스</li></ul> <h3 id="추상화-한-이유"><a href="#추상화-한-이유" class="header-anchor">#</a> 추상화 한 이유</h3> <ul><li>클래스패스 기준으로 리소스 읽어오는 기능 부재</li> <li>ServletContext를 기준으로 상대 경로로 읽어오는 기능 부재</li> <li>새로운 핸들러를 등록하여 특별한 URL 접미사를 만들어 사용할 수는 있지만 구현이 복잡하고 편의성 메소드가 부족</li></ul> <h3 id="인터페이스-둘러보기"><a href="#인터페이스-둘러보기" class="header-anchor">#</a> 인터페이스 둘러보기</h3> <ul><li>상속 받은 인터페이스</li> <li>주요 메서드
<ul><li>getInputStream()</li> <li>exist()</li> <li>isOpen()</li> <li>getDescription() : 전체 경로 포함한 파일 이름 또는 실제 URL</li></ul></li></ul> <h3 id="구현체"><a href="#구현체" class="header-anchor">#</a> 구현체</h3> <ul><li>UrlResource : java.net.URL 참고, 기본으로 지원하는 프로토콜 http, https, ftp, file, jar</li> <li>ClassPathResource : 지원하는 접두어 classpath:
<code>Resource resource = resourceLoader.getResource(&quot;classpath:test.txt&quot;);</code></li> <li>FileSystemResource</li> <li>ServletContextResource : 웹 애플리케이션 루트에서 상대 경로로 리소스 찾음</li> <li>...</li></ul> <h3 id="리소스-읽어오기-2"><a href="#리소스-읽어오기-2" class="header-anchor">#</a> 리소스 읽어오기</h3> <ul><li>Resource의 타입은 location 문자열과 ApplicationContext의 타입에 따라 결정 된다.
<ul><li>ClassPathXmlApplicationContext -&gt; ClassPathResource</li> <li>FileSystemXmlApplicationContext -&gt; FileSystemResource</li> <li>WebApplicationContext -&gt; Servlet ContextResource</li></ul></li> <li><strong>ApplicationContext의 타입에 상관없이 리소스 타입을 강제하려면 java.net.URL 접두어 (+classpath:) 중 하나를 사용할 수 있다.</strong>
접두어가 있으면 이 리소스가 어디서 오는지 더 명확하게 알 수 있음
<ul><li>classpath:me/whiteship/config.xml -&gt; ClassPathResource</li> <li>file:///some.resource/path/config.xml -&gt; FileSystemResource</li></ul></li></ul> <br> <h2 id="_2부-validation-추상화"><a href="#_2부-validation-추상화" class="header-anchor">#</a> 2부. Validation 추상화</h2> <blockquote><p>org.springframework.validation.Validator
애플리케이션에서 사용하는 객체 검증용 인터페이스</p></blockquote> <h3 id="특징-2"><a href="#특징-2" class="header-anchor">#</a> 특징</h3> <ul><li>어떠한 계층과도 관계가 없다 =&gt; 모든 계층(웹, 서비스, 데이터)에서 사용해도 좋다.</li> <li>구현체 중 하나로, JSR-303(Bean Validation 1.0)과 JSR-349(Bean Validation 1.1)을 지원한다. (LocalValidatorFactoryBean)</li> <li>DataBinder에 들어가 바인딩 할 때 같이 사용되기도 한다.</li></ul> <h3 id="인터페이스"><a href="#인터페이스" class="header-anchor">#</a> 인터페이스</h3> <ul><li>boolean supports(Class clazz): 어떤 타입의 객체를 검증할 때 사용할 것인지 결정함</li> <li>void validate(Object obj, Errors e): 실제 검증 로직을 이 안에서 구현
<ul><li>구현할 때 ValidationUtils 사용하며 편리함</li></ul></li></ul> <h3 id="스프링-부트-2-0-5-이상-버전을-사용할-때"><a href="#스프링-부트-2-0-5-이상-버전을-사용할-때" class="header-anchor">#</a> 스프링 부트 2.0.5 이상 버전을 사용할 때</h3> <ul><li>LocalValidatorFactoryBean 빈으로 자동 등록</li> <li>JSR-380(Bean Validation 2.0.1) 구현체로 hibernate-validator 사용</li> <li>https://beanvalidation.org</li></ul> <br> <h1 id="_3-데이터-바인딩"><a href="#_3-데이터-바인딩" class="header-anchor">#</a> 3. 데이터 바인딩</h1> <h2 id="_1부-데이터-바인딩-추상화-propertyeditor"><a href="#_1부-데이터-바인딩-추상화-propertyeditor" class="header-anchor">#</a> 1부. 데이터 바인딩 추상화: PropertyEditor</h2> <h3 id="스프링이-제공하는-databinder-인터페이스"><a href="#스프링이-제공하는-databinder-인터페이스" class="header-anchor">#</a> 스프링이 제공하는 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/validation/DataBinder.html" target="_blank" rel="noopener noreferrer">DataBinder 인터페이스<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <ul><li>기술적인 관점 : property 값을 타겟 객체에 설정하는 기능</li> <li>사용자 관점 : 사용자 입력값을 애플리케이션 도메인 모델에 동적으로 변환해 넣어주는 기능</li> <li>문자열로 받는 입력값을 int, long, boolean, Event, Book 등 단순 타입 또는 객체로 변환해서 넣어주는 기능</li></ul> <h3 id="propertyeditor"><a href="#propertyeditor" class="header-anchor">#</a> PropertyEditor</h3> <ul><li>스프링 3.0 이전까지 DataBinder가 변환 작업 사용하던 인터페이스</li> <li>쓰레드-세이프 하지 않음
상태 정보 저장, 싱글톤 빈으로 사용하는 용도는 적절하지 않음</li> <li>Object와 String 간의 변환만 가능 -&gt; 사용 범위가 제한적</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EventPropertyEditor</span> <span class="token keyword">extends</span> <span class="token class-name">PropertyEditorSupport</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAsText</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Event</span><span class="token punctuation">)</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAsText</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IllegalArgumentException</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Event</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    event<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setValue</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><br> <h1 id="_5-스프링-aop"><a href="#_5-스프링-aop" class="header-anchor">#</a> 5. 스프링 AOP</h1> <h2 id="_1부-개념-소개"><a href="#_1부-개념-소개" class="header-anchor">#</a> 1부. 개념 소개</h2> <p>Aspect-oriented Programming
OOP를 보완하는 수단으로, 흩어진 Aspect를 모둘화 할 수 있는 프로그래밍 기법
Java에 AspectJ라는 구현체와 연동해서 사용도 가능하고, Spring이 구현한 AOP 기능 사용도 가능
eg. 트랜잭션, 로깅</p> <p>흩어진 관심사 (CrossCutting concerns) 를 모듈화 하는게 포인트!</p> <h3 id="aop-주요-개념"><a href="#aop-주요-개념" class="header-anchor">#</a> AOP 주요 개념</h3> <ul><li>Aspect : 공통된 기능을 분리한 모듈
<ul><li>Advice : 해야하는 일들</li></ul></li> <li>Target : 적용이 될 대상</li> <li>Pointcut : 어디에 적용이 되어야 하는지에 대한 정보 (Joint point의 구체적인 subset)</li> <li>Join point : 합류 지점
<ul><li>메서드 실행 시점</li> <li>생성자 호출하기 직전 / 호출했을 때</li> <li>field에 접근하기 전 / field를 가져갔을 때</li></ul></li></ul> <h3 id="aop-구현체"><a href="#aop-구현체" class="header-anchor">#</a> AOP 구현체</h3> <ul><li>자바
<ul><li>AspectJ</li> <li>스프링 AOP
AspectJ 보다는 한정된 기능 제공</li></ul></li></ul> <h3 id="aop-적용-방법"><a href="#aop-적용-방법" class="header-anchor">#</a> AOP 적용 방법</h3> <ul><li>컴파일 타임 : 컴파일 시점에 Advice가 Join Point에 들어있도록 하는 것</li> <li>로딩 타임 : Jvm에서 Target을 로딩하는 시점에 Byte Code를 변경하는 방법 (로드타임 위빙) -&gt; 로딩시점에 부하가 생길 수 있고, 로드 타임에 위버 Java agent를 등록해줘야 함</li> <li>런타임 : Target이 되는 Bean을 생성할 때(Runtime) Target의 타입을 가지는 Proxy Bean을 만듦
Spring AOP가 사용하는 방법
Bean 생성 시 부하가 생길 수 있지만 요청시에 부하는 덜 함</li></ul> <br> <h2 id="_2부-프록시-기반-aop"><a href="#_2부-프록시-기반-aop" class="header-anchor">#</a> 2부. 프록시 기반 AOP</h2> <h3 id="스프링-aop-특징"><a href="#스프링-aop-특징" class="header-anchor">#</a> 스프링 AOP 특징</h3> <ul><li>프록시 기반의 AOP 구현체</li> <li>스프링 빈에만 AOP를 적용할 수 있다.</li> <li>모든 AOP 기능을 제공하는 것이 목적이 아니라, 스프링 IoC와 연동하여 엔터프라이즈 애플리케이션에서 가장 흔한 문제에 대한 해결책을 제공하는 것이 목적</li></ul> <h3 id="프록시-패턴"><a href="#프록시-패턴" class="header-anchor">#</a> 프록시 패턴</h3> <ul><li>WHY?
(기존 코드 변경 없이) <strong>접근 제어 또는 부가 기능 추가</strong> <img src="/TIL/assets/img/proxy-pattern.37d22b1a.png" alt="프록시패턴">
Proxy 객체는 target 객체(Real Subject)를 한번 감싸서 Real Subject(target 객체)를 사용</li> <li>기존 코드를 건드리지 않고 성능을 측정해 보자.</li></ul> <h3 id="문제점"><a href="#문제점" class="header-anchor">#</a> 문제점</h3> <ul><li>매번 프록시 클래스를 작성해야 하는가?</li> <li>여러 클래스 여러 메소드에 적용하려면?</li> <li>객체들 관계도 복잡..</li></ul> <h3 id="이를-해결하기-위해-등장한-것이-스프링-aop"><a href="#이를-해결하기-위해-등장한-것이-스프링-aop" class="header-anchor">#</a> 이를 해결하기 위해 등장한 것이 스프링 AOP</h3> <ul><li>스프링 IoC 컨테이너가 제공하는 기반 시설과 Dynamic 프록시를 사용하여 여러 복잡한 문제 해결</li> <li>동적 프록시: 동적으로 프록시 객체 생성하는 방법
<ul><li>자바가 제공하는 방법은 인터페이스 기반 프록시 생성
-&gt; 해당 인터페이스의 실제 구현체에 의존성을 가지는 Proxy bean을 생성하는 방법</li> <li>CGlib는 클래스 기반 프록시도 지원</li></ul></li> <li>스프링 IoC: 기존 빈을 대체하는 동적 프록시 빈을 만들어 등록 시켜준다.
<ul><li>클라이언트 코드 변경 없음</li> <li>AbstractAutoProxyCreator implement BeanPostProcessor
이걸로 SimpleEventService를 감싸는 프록시 bean을 만들어서</li></ul></li></ul> <br> <h2 id="_3부-aop"><a href="#_3부-aop" class="header-anchor">#</a> 3부. @AOP</h2> <p>애노테이션 기반의 스프링 @AOP</p> <h3 id="의존성-추가"><a href="#의존성-추가" class="header-anchor">#</a> 의존성 추가</h3> <div class="language-gradle extra-class"><pre class="language-text"><code>implementation 'org.springframework.boot:spring-boot-starter-aop'
</code></pre></div><h3 id="aspect-정의"><a href="#aspect-정의" class="header-anchor">#</a> Aspect 정의</h3> <ul><li>@Aspect</li> <li>빈으로 등록해야 함
<ul><li>ApplicationContext에 직접 추가 또는 @Component도 추가</li></ul></li></ul> <h3 id="포인트컷-정의"><a href="#포인트컷-정의" class="header-anchor">#</a> 포인트컷 정의</h3> <ul><li>@Pointcut (표현식)</li> <li>주요 표현식
<ul><li>execution
@Around(&quot;execution(* kiyeon.practice..<em>.EventService.</em>(..))&quot;)</li> <li>@annotation
@Around(&quot;@annotation(PerfLogging)&quot;)</li> <li>bean
@Around(&quot;bean(simpleEventService)&quot;)</li></ul></li></ul> <h3 id="어드바이스-정의"><a href="#어드바이스-정의" class="header-anchor">#</a> 어드바이스 정의</h3> <ul><li>@Before</li> <li>@AfterReturning</li> <li>@AfterThrowing</li> <li>@Around</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/TIL/assets/js/app.14df79b1.js" defer></script><script src="/TIL/assets/js/2.dce8ba1c.js" defer></script><script src="/TIL/assets/js/8.130adf09.js" defer></script>
  </body>
</html>
